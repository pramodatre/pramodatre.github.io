<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Disparity Map Computation in Python and C++ – Pramod Anantharam</title>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Disparity map is an essential part of Stereo Vision. This post will walk you through the implementation details with code in python and C++">
    <link rel="manifest" type="application/manifest+json; charset=utf-8" href="/manifest.json">
    <meta name="robots" content="all">
    <meta name="author" content="Pramod Anantharam">
    
    <meta name="keywords" content="">
    <link rel="canonical" href="http://localhost:4000/2020/05/14/stereo-vision-exploration/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Pramod Anantharam" href="/feed.xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202005190614" type="text/css">

    <!-- Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lato:900,300" rel="stylesheet" type="text/css">
    
    
      <link href="//maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css" rel="stylesheet">
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Disparity Map Computation in Python and C++">
    <meta property="og:description" content="Pramod Anantharam">
    <meta property="og:url" content="http://localhost:4000/2020/05/14/stereo-vision-exploration/">
    <meta property="og:site_name" content="Pramod Anantharam">
    

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    
        <meta name="twitter:site" content="@pramodatre">
        <meta name="twitter:creator" content="@pramodatre">
    
    <meta name="twitter:title" content="Disparity Map Computation in Python and C++">
    <meta name="twitter:description" content="Disparity map is an essential part of Stereo Vision. This post will walk you through the implementation details with code in python and C++">
    <meta name="twitter:url" content="http://localhost:4000/2020/05/14/stereo-vision-exploration/">
    

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="shortcut icon" href="/favicon.ico">

    
<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({         tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] }       });</script>
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">Pramod Anantharam</a>
      <nav class="site-nav">
        



    
    
    
    
        <a class="nav-link" href="/about/">About Me</a>
    

    

    
    
    
    
        <a class="nav-link" href="/old_site/">PhD Life</a>
    

    

    
    
    
    
        <a class="nav-link" href="/contact/">Say Hello</a>
    

    


      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="social-icons-right">
    
      <a class="fa fa-github" href="https://github.com/pramodatre"></a>
    
    
    
    
    <a class="fa fa-rss" href="/feed.xml"></a>
    
      <a class="fa fa-twitter" href="https://twitter.com/pramodatre"></a>
    
    
    
    
    
      <a class="fa fa-envelope" href="mailto:pramod.atre@gmail.com"></a>
    
    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/pramodprofile"></a>
    
    
    
      <a class="fa fa-medium" href="https://medium.com/@pramod.atre"></a>
    
    
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Disparity Map Computation in Python and C++</h1>
  <span class="post-meta">May 14, 2020</span><br>
  
  <span class="post-meta small">
  
    17 minute read
  
  </span>
</div>

<article class="post-content">
  <p>Stereo vision is the term used for the process of inferring 3D depth information from 2D images <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. 2D images may be from a Stereo Rig, usually consisting of two cameras slightly displaced horizontally similar to our two eyes. In fact, stereopsis <sup id="fnref:1:1"><a href="#fn:1" class="footnote">1</a></sup> takes inspiration from our ability to infer depth information using our eyes. For a deeper explanation of stereo vision, you can refer to <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> <sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. A comprehensive and clear explanation of Stereo Vision is presented here <sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>. If you would like to understand depth calculation clearly, you can refer to <sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>. In this post, I will walk you through the implementation steps in python and subsequent parallel implementation in C++.</p>

<h2 id="depth-estimation">Depth Estimation</h2>
<p>Before we proceed coding, I would like to explain <code class="highlighter-rouge">how can we estimate depth using the disparity map?</code> Without this motivation, I feel it is pointless to explain disparity map implementation. I had difficulty understanding a specific part of the derivation of depth equation which I will point out later. May be it’s just me but thought I will write this up so that it may help someone who may have similar question as I did. A simplified stereo setup with two cameras is shown here. It’s a bird’s eye view of the camera setup and a point $P$ for which we are trying to estimate the depth/distance form the camera. To estimate depth from stereo implies that we need to estimate $Z$ in the figure. $Z$ is the distance of point $P$ from the camera.</p>

<!-- _includes/image.html -->
<div class="image-wrapper-small">
    
    <a href="https://www.cc.gatech.edu/~afb/classes/CS4495-Fall2013/slides/CS4495-06-Stereo.pdf" title="stereo_geometry" target="_blank">
    
        <img src="http://localhost:4000/images/2020-05-30/stereo_geometry.png" alt="stereo_geometry">
    
    </a>
    
    
        <p class="image-caption">Derivation of depth for a simple stereo example with two cameras with perfectly aligned image and having same focal lengths. (source: CS 4495 Computer Vision – A. Bobick)</p>
    
</div>

<p>In the above setup, let $C_{L}$ be the camera on the left and $C_{R}$ be the camera on the right. Both these cameras have the same focal length $f$. Distance between camera centers is $B$. A line from point $P$ to the camera center of $C_{L}$ intersects the image plane at $p_{l}$. A line from point $P$ to camera center of $C_{R}$ intersects $C_{R}$’s image plane at $p_{r}$. Note that the triangles $p_{l} P p_{r}$ and $C_{L}PC_{R}$ are similar triangles. Since these triangles are similar, their ratio of base to height should be the same, i.e., $\frac{B}{Z}$ = $\frac{p_{l}p_{r}}{Z-f}$. From the figure, we have $p_{l}p_{r}$ to be $B - (x_{l}+x_{r})$. However, in all the derivations in multiple references, $p_{l}p_{r}$ is told to be $B - x_{l} + x_{r}$ which totally confused me. It is quite clear from the figure, to get $p_{l}p_{r}$ we need to subtract ($x_{l} + x_{r}$) from $B$.</p>

<p>Let’s say I would like to test my hypothesis that $p_{l}p_{r} = B - (x_{l}+x_{r})$. When we use our depth sensing system in practice, we will have to feed in the focal length ($f$), base length ($B$), $x_{l}$, and $x_{r}$ to obtain $Z$ which is the depth estimation for point $P$. $x_{l}$ is a positive value since it is to the right of the camera center line passing through the image plane which serves as the origin. Similarly, $x_{r}$ is a negative number since it is to the left of the $C_{R}$’s center line which serves the origin. Now, if we use the equation $p_{l}p_{r} = B - (x_{l}+x_{r})$ with -ve value for $x_{r}$ we end up adding $x_{r}$ to $B$ instead of subtracting, i.e., we will end up with $p_{l}p_{r} = B - (x_{l}-x_{r}) = B - x_{l} + x_{r}$. This length is incorrect. Say, we used $p_{l}p_{r} = B - (x_{l}-x_{r})$ and since we have $x_{r}$ as negative, $p_{l}p_{r} = B - (x_{l}-(-x_{r})) = B - (x_{l}+x_{r})$. This is the reason we have $-x_{r}$ in the equation to estimate depth from stereo images. Now, a negative sign for $x_{r}$ in the depth estimation equation makes sense to me. So, finally, to estimate depth, we can use the following equation $Z=f \frac{B}{x_{l}-x_{r}}$.</p>

<h2 id="disparity-map">Disparity Map</h2>
<p>Depth is inversely proportional to disparity, i.e., from the depth estimation equation, we have $Z \propto \frac{1}{x_{l}-x_{r}}$. As disparity ($x_{l}-x_{r}$) increases, $Z$ decreases and for lower disparity ($x_{l}-x_{r}$), we would have higher $Z$. This is intuitive if you hold your index finger near your eyes and alternate seeing from your left and right eyes. You will notice that your finger jumps a lot in your view compared to other distant object. We will use a technique called block matching to find the correspondences between pixels in the two images as outlined in <sup id="fnref:2:1"><a href="#fn:2" class="footnote">2</a></sup>. Here is a summary of steps we need for computing disparity map:</p>
<ul>
  <li>Input: Left image and right image (from perfectly aligned cameras) of width $w$ and height $h$, block size in pixels, and search block size</li>
  <li>Output: Disparity map of width $w$ and height $h$</li>
  <li>Why do we need to specify block size and search block size?
    <ul>
      <li>For every pixel in the left image, we need to find the corresponding pixel in the right image. Since pixel values may be noisy and is influenced by many factors such as sensor noise, lighting, mis-alignment, etc., we may have to rely on a group of surrounding pixels for comparison.</li>
      <li>
<strong><em>Block size</em></strong> refers to the neighborhood size we select to compare pixels from left image and the right image specified as number of pixels in height and width. An example block is shown as a white box in both left and right images.</li>
      <li>
<strong><em>Search block size</em></strong> refers to a rectangle (shown in black on the right image) in which we will search for best matching block. Notice that in the third figure, you will have to move the white smaller rectangle to the left to get a best match of pixel similarity.</li>
    </ul>
  </li>
</ul>

<!-- _includes/image.html -->
<div class="image-wrapper">
    
    <a href="http://vision.middlebury.edu/stereo/data/scenes2003/" title="block_matching" target="_blank">
    
        <img src="http://localhost:4000/images/2020-05-30/block_matching.png" alt="block_matching">
    
    </a>
    
    
        <p class="image-caption">Block matching example. (Image source: Middlebury Stereo Datasets)</p>
    
</div>

<ul>
  <li>For a pixel in the left image, select the pixels in it’s neighborhood specified as block size from the left image.</li>
  <li>Compute similarity score for each block (same size as block size) selected from the search block and keep sliding the block by one pixel within the search block. Record all the similarity scores.</li>
  <li>Find the highest pixel similarity score and use the pixel at the block center as the corresponding pixel for the left pixel/block we are trying to find the best match.</li>
  <li>If $x_{l}$ is the column index of the left pixel, and the highest similarity score was obtained for a block on the right image whose center is the pixel with column in index $x_{r}$, we will note the disparity value of $\left|x_{l}-x_{r}\right|$ for the location of left image pixel.</li>
  <li>Repeat the matching process for each pixel in the left image and note all the disparity values for the left image pixel index.</li>
  <li>We will start building the basic building blocks first and later combine these building blocks to compute disparity map.</li>
</ul>

<h3 id="similarity-metric">Similarity metric</h3>
<p>We need to define a notion of similarity between two blocks of pixels. Sum of absolute difference between pixel values is an intuitive metric for similarity. For example, the pair (3,5) is more similar compared to the pair (3,6) since the absolute difference between numbers in the first pair |3 - 5| &lt; difference between numbers in the second pair |3 - 6|, i.e., 2 &lt; 3. If there are multiple such values for comparison, we sum up the differences. Hence, we will implement sum of absolute difference method. We will loop over each row ($i$) and column ($j$) in both left and right blocks we are given using $\Sigma_{i,j} |B_{i,j}^{l} - B_{i,j}^{r}|$. Pixel blocks with lower sum of absolute difference value are more similar than pixel blocks with higher sum of absolute difference value.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">sum_of_abs_diff</span><span class="p">(</span><span class="n">pixel_vals_1</span><span class="p">,</span> <span class="n">pixel_vals_2</span><span class="p">):</span>
    <span class="s">"""
    Args:
        pixel_vals_1 (numpy.ndarray): pixel block from left image
        pixel_vals_2 (numpy.ndarray): pixel block from right image

    Returns:
        float: Sum of absolute difference between individual pixels
    """</span>
    <span class="k">if</span> <span class="n">pixel_vals_1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">pixel_vals_2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pixel_vals_1</span> <span class="o">-</span> <span class="n">pixel_vals_2</span><span class="p">))</span></code></pre></figure>

<h3 id="block-comparisons">Block comparisons</h3>
<p>We can compare a block of pixels from the left image with a block of pixels in the right image using the <code class="highlighter-rouge">sum_of_abs_diff</code> method we just defined. However, note that we need to compare a single block of pixels in the left image to multiple block of pixels on the right image (like we defined in <code class="highlighter-rouge">Why do we need to specify block size and search block size?</code>). These multiple blocks are to be selected within the search block shown as a black rectangle in the above figure. We will slide the white box one pixel at a time (starting from left) to get candidate blocks for comparison from the right image. We note the block from the right image that has lowest sum of absolute difference score. The corresponding row and column index (y, x) is returned by our implementation here.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">SEARCH_BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">56</span>

<span class="k">def</span> <span class="nf">compare_blocks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">block_left</span><span class="p">,</span> <span class="n">right_array</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="s">"""
    Compare left block of pixels with multiple blocks from the right
    image using SEARCH_BLOCK_SIZE to constrain the search in the right
    image.

    Args:
        y (int): row index of the left block
        x (int): column index of the left block
        block_left (numpy.ndarray): containing pixel values within the 
                    block selected from the left image
        right_array (numpy.ndarray]): containing pixel values for the 
                     entrire right image
        block_size (int, optional): Block of pixels width and height. 
                                    Defaults to 5.

    Returns:
        tuple: (y, x) row and column index of the best matching block 
                in the right image
    """</span>
    <span class="c1"># Get search range for the right image
</span>    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">SEARCH_BLOCK_SIZE</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">SEARCH_BLOCK_SIZE</span><span class="p">)</span>
    <span class="c1">#print(f'search bounding box: ({y, x_min}, ({y, x_max}))')
</span>    <span class="n">first</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">min_sad</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">min_index</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">):</span>
        <span class="n">block_right</span> <span class="o">=</span> <span class="n">right_array</span><span class="p">[</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">+</span><span class="n">block_size</span><span class="p">,</span>
                                  <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">block_size</span><span class="p">]</span>
        <span class="n">sad</span> <span class="o">=</span> <span class="n">sum_of_abs_diff</span><span class="p">(</span><span class="n">block_left</span><span class="p">,</span> <span class="n">block_right</span><span class="p">)</span>
        <span class="c1">#print(f'sad: {sad}, {y, x}')
</span>        <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
            <span class="n">min_sad</span> <span class="o">=</span> <span class="n">sad</span>
            <span class="n">min_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sad</span> <span class="o">&lt;</span> <span class="n">min_sad</span><span class="p">:</span>
                <span class="n">min_sad</span> <span class="o">=</span> <span class="n">sad</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">min_index</span></code></pre></figure>

<h3 id="disparity-calculation">Disparity calculation</h3>
<p>We can use the block comparison implementation to compute disparity values for every pixel between left and right images. As explained earlier, we will use a pixel blocks (neighboring pixels) to find pixel correspondences between left and right images. To do this, for a pixel at row $r$ and column $c$ from the left image, we select block of pixels $b_{r, c}$ from the left image using BLOCK_SIZE parameter. We invoke block comparison for $b_{r, c}$ and get back min_index containing row and column index of the best matching pixel from the right image, $(y, x)$. For the pixel (r, c) of the left image, the best matching pixel from the right image is at (y, x). The disparity for pixel (r, c) is computed using $|c - x|$. We need to compute disparity for each pixel of the left image and collect disparity values in a matrix of size width and height of the left/right image.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">input_image</span><span class="o">.</span><span class="n">shape</span>
<span class="n">disparity_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
<span class="n">min_index</span> <span class="o">=</span> <span class="n">compare_blocks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">block_left</span><span class="p">,</span> <span class="n">right_array</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="n">BLOCK_SIZE</span><span class="p">)</span>
<span class="n">disparity_map</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">min_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span></code></pre></figure>

<h3 id="disparity-map-1">Disparity map</h3>
<p>Let’s now setup a loop to go over each pixel in the left image, select a block of pixels from the left image, invoke compare_blocks, compute disparity values, and store disparity values in a disparity matrix which we call the disparity map.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">,</span> <span class="n">h</span><span class="o">-</span><span class="n">BLOCK_SIZE</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="n">BLOCK_SIZE</span><span class="p">):</span>
            <span class="n">block_left</span> <span class="o">=</span> <span class="n">left_array</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span>
                                    <span class="n">x</span><span class="p">:</span><span class="n">x</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">]</span>
            <span class="n">min_index</span> <span class="o">=</span> <span class="n">compare_blocks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">block_left</span><span class="p">,</span>
                                       <span class="n">right_array</span><span class="p">,</span>
                                       <span class="n">block_size</span><span class="o">=</span><span class="n">BLOCK_SIZE</span><span class="p">)</span>
            <span class="n">disparity_map</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">min_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span></code></pre></figure>

<p>Here is a visualization of the disparity map computed for left and right images shown above.</p>

<!-- _includes/image.html -->
<div class="image-wrapper-small">
    
        <img src="http://localhost:4000/images/2020-05-30/disparity_image.png" alt="disparity_map">
    
    
        <p class="image-caption">Visualization of disparity values computed using left and right image of the scene shown in the first figure. Hot/lighter color indicates higher value of disparity and cooler/darker color indicates lower value of disparity</p>
    
</div>

<p>We use <code class="highlighter-rouge">tqdm</code> to show progress and note the time it takes to compute the disparity map in python. 
<!-- _includes/image.html --></p>
<div class="image-wrapper">
    
        <img src="http://localhost:4000/images/2020-05-30/run_time_python.png" alt="run_time_python">
    
    
        <p class="image-caption">Disparity map computation run time</p>
    
</div>

<p>Disparity map computation using this python took <code class="highlighter-rouge">2 minutes 37 seconds</code> for left and right images of size (height=375, width=450). I was quite disappointed by this slow run-time for such a small image size and wondered about the practical use of my python implementation. There are many optimizations proposed in <sup id="fnref:2:2"><a href="#fn:2" class="footnote">2</a></sup> and <sup id="fnref:3:1"><a href="#fn:3" class="footnote">3</a></sup>. The most obvious one for me is at least use all the compute power on my machine. Since python cannot take advantage of all the cores on my machine, I thought of using C++ to parallelize the disparity map computation.</p>

<h2 id="parallel-implementation-in-c">Parallel implementation in C++</h2>
<p>Comparing pixel blocks from the left image (white box, left image) with the pixel blocks (white box, right image) selected from the search block (black rectangle in the first figure) of the right image can be done in parallel. A naive approach may be to create a thread pool and assign a single block comparison to a thread. Later, after block comparison for each pixel in the left image, we accumulate all the results into a disparity map. One concern is the cost of spawning a thread and later aggregating all the results which probably impedes the benefits of parallelizing this computation.</p>

<p>A slightly practical approach to parallelize is to find the number of cores on the machine where the disparity map computation to inform the task distribution. We can split disparity map computation into $n$ chunks where $n$ is the number of cores on your machine. Think of the left image and right image as 2D space split into $n$ horizontal strips. We will compute disparity map for each strip pair (one from left image and another from right image) in parallel. Later, we will combine the $n$ disparity maps into a single disparity map. Since this approach leverages all the cores on the machine, we should see a gain in performance.</p>

<h3 id="similarity-metric-and-block-comparisons">Similarity metric and block comparisons</h3>
<p>Let’s start with some basic methods we need. First, we need a method to compare blocks selected from left and right images. We will write a general method that can do block comparison for a given pixel location and pixel block width and height. Method compare_blocks implemented here returns the disparity value for a specified pixel index (row, col) and block size (width, height).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">compare_blocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span> <span class="o">*</span><span class="n">left_img</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span> <span class="o">*</span><span class="n">right_img</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_col</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>
    <span class="c1">// compute bounding box for left image with (row, col) as top left point</span>
    <span class="c1">// compute bottom right point using (row, col)</span>
    <span class="kt">int</span> <span class="n">bottom_row</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// zero indexed, hence using (height - 1)</span>
    <span class="kt">int</span> <span class="n">bottom_col</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// compute bounding box for right image block in which </span>
    <span class="c1">// we will scan and compare left block</span>
    <span class="kt">int</span> <span class="n">col_min</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="n">SEARCH_BLOCK_SIZE</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">col_max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">SEARCH_BLOCK_SIZE</span><span class="p">);</span> 
    <span class="kt">bool</span> <span class="n">first_block</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_sad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r_indx</span> <span class="o">=</span> <span class="n">col_min</span><span class="p">;</span> <span class="n">r_indx</span> <span class="o">&lt;</span> <span class="n">col_max</span><span class="p">;</span> <span class="o">++</span><span class="n">r_indx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bottom_row</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">r_img_col</span> <span class="o">=</span> <span class="n">r_indx</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bottom_col</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Scalar</span> <span class="n">left_pixel</span> <span class="o">=</span> <span class="n">left_img</span><span class="o">-&gt;</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="c1">// Right image index should be updated using offset</span>
                <span class="c1">// since we need to scan both left and right of the</span>
                <span class="c1">// block from the left image </span>
                <span class="n">Scalar</span> <span class="n">right_pixel</span> <span class="o">=</span> <span class="n">right_img</span><span class="o">-&gt;</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r_img_col</span><span class="p">);</span>
                <span class="n">sad</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">left_pixel</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">right_pixel</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="o">++</span><span class="n">r_img_col</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> 

        <span class="k">if</span><span class="p">(</span><span class="n">first_block</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">min_sad</span> <span class="o">=</span> <span class="n">sad</span><span class="p">;</span>
            <span class="n">min_col</span> <span class="o">=</span> <span class="n">r_indx</span><span class="p">;</span>
            <span class="n">first_block</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sad</span> <span class="o">&lt;</span> <span class="n">min_sad</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">min_sad</span> <span class="o">=</span> <span class="n">sad</span><span class="p">;</span>
                <span class="n">min_col</span> <span class="o">=</span> <span class="n">r_indx</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//cout &lt;&lt; "min sad: " &lt;&lt; min_sad &lt;&lt; " ";</span>

    <span class="k">return</span> <span class="n">col</span> <span class="o">-</span> <span class="n">min_col</span><span class="p">;</span>
<span class="p">}</span> </code></pre></figure>

<h3 id="disparity-calculation-1">Disparity calculation</h3>
<p>We can invoke block comparisons for each pixel in the left image using the following set-up. Here, the start and end rows and columns of the chunks are passed as argument. I will next describe the derivation of these indexes.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">compute_disparity</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_chunk_row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end_chunk_row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_chunk_col</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end_chunk_col</span><span class="p">,</span> <span class="n">Mat</span> <span class="o">*</span><span class="n">left_img</span><span class="p">,</span> <span class="n">Mat</span> <span class="o">*</span><span class="n">right_img</span><span class="p">,</span> <span class="n">Mat</span> <span class="o">*</span><span class="n">disparity_map</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">left_img</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">left_img</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start_chunk_row</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_chunk_row</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">start_chunk_col</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">end_chunk_col</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">compare_blocks</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">left_img</span><span class="p">,</span> <span class="n">right_img</span><span class="p">);</span> 
            <span class="k">if</span><span class="p">(</span><span class="n">disp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
                <span class="n">disparity_map</span><span class="o">-&gt;</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
                <span class="n">disparity_map</span><span class="o">-&gt;</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">disp</span><span class="p">;</span>
                <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> 
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3 id="chunking">Chunking</h3>
<p>To chunk disparity map computation, we need to find the indices for each chunk we want to process. We will implement the method get_chunk_indices which takes maximum range of the index and number of chunks to produce. We will return the chunk indices.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">get_chunk_indices</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_chunks</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">chunks</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">max</span> <span class="o">/</span> <span class="n">num_chunks</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">chunks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">chunks</span><span class="p">[</span><span class="n">chunks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">chunks</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="spawning-threads">Spawning threads</h3>
<p>We will spawn specified number of threads and on each thread we will compute disparity values for a single chunk. Each thread populates the disparity map and when all the threads finish, disparity_map will contain the final disparity map.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">height_chunks</span> <span class="o">=</span> <span class="n">get_chunk_indices</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height_chunks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">compute_disparity</span><span class="p">,</span> <span class="n">height_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">height_chunks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> 
    <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left_img</span><span class="p">,</span> <span class="n">right_img</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disparity_map</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Here is the console output for the parallelize computation of disparity map. Complete disparity map calculation took just <code class="highlighter-rouge">6 seconds</code>! Just to recap, with the python implementation, disparity map calculation took <code class="highlighter-rouge">2 minutes, 37 seconds</code>. Using this C++ implementation, we get 26X gain in speed of computing the disparity map.</p>

<figure class="highlight"><pre><code class="language-code" data-lang="code">$ g++ $(pkg-config --cflags --libs opencv4) -std=c++11 stereo_vision_parallel.cpp -o stereo_vision
$ ./stereo_vision data/left.png data/right.png
Left image shape: [450 x 375]
Right image shape: [450 x 375]
Initial disparity map: [450 x 375]
Total entries in disparity map: 168750
Using 8 threads for computation...
Execution time: 6 seconds (0.1) mins</code></pre></figure>

<p>Here the visualization of the disparity map calculated using the parallel implementation.
<!-- _includes/image.html --></p>
<div class="image-wrapper-small">
    
        <img src="http://localhost:4000/images/2020-05-30/disparity_image_cpp.png" alt="disparity_image_cpp">
    
    
        <p class="image-caption">Visualization of disparity values computed using parallel implementation in C++. Hot/lighter color indicates higher value of disparity and cooler/darker color indicates lower value of disparity</p>
    
</div>

<h3 id="conclusion">Conclusion</h3>
<p>We were able to implement the basic idea of stereo vision to compute disparity values. Without any optimizations, the python implementation is too slow for any practical use. With parallel implementation, we reduced the running time for 375 by 450 pixels image form <code class="highlighter-rouge">2 minutes 37 seconds</code> to just <code class="highlighter-rouge">6 seconds</code>. Even though this is a significant jump in performance, it is far from practical use for any real-time systems that rely on stereo to estimate its environment. For example, a robot using vision guided navigation cannot afford to spend 6 seconds for processing two frames (one from left and and another from right camera). A far more optimized computation is necessary especially for real-time consumption of depth information.</p>

<p><strong>All the source code presented in this post can be found <a href="https://github.com/pramodatre/cv-algorithms/tree/master/stereo_vision">here</a></strong></p>

<hr>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Forsyth, D., &amp; Ponce, J. (2003). Computer vision: A modern approach. Upper Saddle River, N.J: Prentice Hall. <a href="#fnref:1" class="reversefootnote">↩</a> <a href="#fnref:1:1" class="reversefootnote">↩<sup>2</sup></a></p>
    </li>
    <li id="fn:2">
      <p>http://mccormickml.com/2014/01/10/stereo-vision-tutorial-part-i/ <a href="#fnref:2" class="reversefootnote">↩</a> <a href="#fnref:2:1" class="reversefootnote">↩<sup>2</sup></a> <a href="#fnref:2:2" class="reversefootnote">↩<sup>3</sup></a></p>
    </li>
    <li id="fn:3">
      <p>http://mccormickml.com/assets/StereoVision/Stereo%20Vision%20-%20Mathworks%20Example%20Article.pdf <a href="#fnref:3" class="reversefootnote">↩</a> <a href="#fnref:3:1" class="reversefootnote">↩<sup>2</sup></a></p>
    </li>
    <li id="fn:4">
      <p>http://vision.deis.unibo.it/~smatt/Seminars/StereoVision.pdf <a href="#fnref:4" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:5">
      <p>https://www.cc.gatech.edu/~afb/classes/CS4495-Fall2013/slides/CS4495-06-Stereo.pdf <a href="#fnref:5" class="reversefootnote">↩</a></p>
    </li>
  </ol>
</div>

</article>






  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'https-pramodatre-github-io';
    var disqus_identifier = '/2020/05/14/stereo-vision-exploration';
    var disqus_title      = "Disparity Map Computation in Python and C++";

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>








      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Theme based on <a href="https://github.com/johnotander/pixyll">Pixyll</a>.
    </small>
  </div>
</footer>

<script type="text/javascript">
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js")
    }
</script>

</body>
</html>
