<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-05-17">

<title>blog - Disparity Map Computation in Python and C++</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/pramodatre" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/pramodatre" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Disparity Map Computation in Python and C++</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">depth estimation</div>
                <div class="quarto-category">stereo vision from images</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 17, 2020</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Stereo vision is the term used for the process of inferring 3D depth information from 2D images <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. 2D images may be from a Stereo Rig, usually consisting of two cameras slightly displaced horizontally similar to our two eyes. In fact, stereopsis <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> takes inspiration from our ability to infer depth information using our eyes. For a deeper explanation of stereo vision, you can refer to <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. A comprehensive and clear explanation of Stereo Vision is presented here <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. If you would like to understand depth calculation clearly, you can refer to <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. In this post, I will walk you through the implementation steps in python and subsequent parallel implementation in C++.</p>
<section id="depth-estimation" class="level2">
<h2 class="anchored" data-anchor-id="depth-estimation">Depth Estimation</h2>
<p>Before we proceed coding, I would like to explain <code>how can we estimate depth using the disparity map?</code> Without this motivation, I feel it is pointless to explain disparity map implementation. I had difficulty understanding a specific part of the derivation of depth equation which I will point out later. May be it’s just me, but, I thought of writing this up so that it may help others who may have similar question as I did. A simplified stereo setup with two cameras is shown here. It’s a bird’s eye view of the camera setup and a point <span class="math inline">\(P\)</span> for which we are trying to estimate the depth/distance form the camera. To estimate depth from stereo implies that we need to estimate <span class="math inline">\(Z\)</span> in the figure. <span class="math inline">\(Z\)</span> is the distance of point <span class="math inline">\(P\)</span> from the camera.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="stereo_geometry.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 1. Derivation of depth for a simplified stereo setting with two cameras with perfectly aligned centers and having same focal lengths. (source: CS 4495 Computer Vision – A. Bobick)</figcaption>
</figure>
</div>
<p>In the above setup, let <span class="math inline">\(C_{L}\)</span> be the camera on the left and <span class="math inline">\(C_{R}\)</span> be the camera on the right. Both these cameras have the same focal length <span class="math inline">\(f\)</span>. Distance between camera centers is <span class="math inline">\(B\)</span>. A line from point <span class="math inline">\(P\)</span> to the camera center of <span class="math inline">\(C_{L}\)</span> intersects the image plane at <span class="math inline">\(p_{l}\)</span>. A line from point <span class="math inline">\(P\)</span> to camera center of <span class="math inline">\(C_{R}\)</span> intersects <span class="math inline">\(C_{R}\)</span>’s image plane at <span class="math inline">\(p_{r}\)</span>. Note that the triangles <span class="math inline">\(p_{l} P p_{r}\)</span> and <span class="math inline">\(C_{L}PC_{R}\)</span> are similar triangles. Since these triangles are similar, their ratio of base to height should be the same, i.e., <span class="math inline">\(\frac{B}{Z}\)</span> = <span class="math inline">\(\frac{p_{l}p_{r}}{Z-f}\)</span>. From the figure, we have <span class="math inline">\(p_{l}p_{r}\)</span> to be <span class="math inline">\(B - (x_{l}+x_{r})\)</span>. However, in all the derivations in multiple references, <span class="math inline">\(p_{l}p_{r}\)</span> is told to be <span class="math inline">\(B - x_{l} + x_{r}\)</span> which totally confused me. It is quite clear from the figure, to get <span class="math inline">\(p_{l}p_{r}\)</span> we need to subtract (<span class="math inline">\(x_{l} + x_{r}\)</span>) from <span class="math inline">\(B\)</span>.</p>
<p>Let’s say I would like to test my hypothesis that <span class="math inline">\(p_{l}p_{r} = B - (x_{l}+x_{r})\)</span>. When we use our depth sensing system in practice, we will have to feed in the focal length (<span class="math inline">\(f\)</span>), base length (<span class="math inline">\(B\)</span>), <span class="math inline">\(x_{l}\)</span>, and <span class="math inline">\(x_{r}\)</span> to obtain <span class="math inline">\(Z\)</span> which is the depth estimation for point <span class="math inline">\(P\)</span>. <span class="math inline">\(x_{l}\)</span> is a positive value since it is to the right of the camera center line passing through the image plane which serves as the origin. Similarly, <span class="math inline">\(x_{r}\)</span> is a negative number since it is to the left of the <span class="math inline">\(C_{R}\)</span>’s center line which serves as the origin. Now, if we use the equation <span class="math inline">\(p_{l}p_{r} = B - (x_{l}+x_{r})\)</span> with -ve value for <span class="math inline">\(x_{r}\)</span> we end up adding <span class="math inline">\(x_{r}\)</span> to <span class="math inline">\(B\)</span> instead of subtracting, i.e., we will end up with <span class="math inline">\(p_{l}p_{r} = B - (x_{l}-x_{r}) = B - x_{l} + x_{r}\)</span>. This length is incorrect. Say, we used <span class="math inline">\(p_{l}p_{r} = B - (x_{l}-x_{r})\)</span> and since we have <span class="math inline">\(x_{r}\)</span> as negative, <span class="math inline">\(p_{l}p_{r} = B - (x_{l}-(-x_{r})) = B - (x_{l}+x_{r})\)</span>. This is the reason we have <span class="math inline">\(-x_{r}\)</span> in the equation to estimate depth from stereo images. Now, a negative sign for <span class="math inline">\(x_{r}\)</span> in the depth estimation equation makes sense to me. So, finally, to estimate depth, we can use the following equation <span class="math inline">\(Z=f \frac{B}{x_{l}-x_{r}}\)</span>.</p>
</section>
<section id="disparity-map" class="level2">
<h2 class="anchored" data-anchor-id="disparity-map">Disparity Map</h2>
<p>Depth is inversely proportional to disparity, i.e., from the depth estimation equation, we have <span class="math inline">\(Z \propto \frac{1}{x_{l}-x_{r}}\)</span>. As disparity (<span class="math inline">\(x_{l}-x_{r}\)</span>) increases, <span class="math inline">\(Z\)</span> decreases and for lower disparity (<span class="math inline">\(x_{l}-x_{r}\)</span>), we would have higher <span class="math inline">\(Z\)</span>. This is intuitive if you hold your index finger near your eyes and alternate seeing from your left and right eyes. You will notice that your finger jumps a lot in your view compared to other distant objects. We will use a technique called block matching to find the correspondences between pixels in the two images as outlined in <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. Here is a summary of steps we need for computing disparity map:</p>
<ul>
<li>Input: Left image and right image (from perfectly aligned cameras) of width <span class="math inline">\(w\)</span> and height <span class="math inline">\(h\)</span>, block size in pixels, and search block size</li>
<li>Output: Disparity map of width <span class="math inline">\(w\)</span> and height <span class="math inline">\(h\)</span></li>
<li>Why do we need to specify block size and search block size?
<ul>
<li>For every pixel in the left image, we need to find the corresponding pixel in the right image. Since pixel values may be noisy and is influenced by many factors such as sensor noise, lighting, mis-alignment, etc., we may have to rely on a group of surrounding pixels for comparison.</li>
<li><strong><em>Block size</em></strong> refers to the neighborhood size we select to compare pixels from left image and the right image specified as number of pixels in height and width. An example block is shown as a white box in both left and right images in Figure 2.</li>
<li><strong><em>Search block size</em></strong> refers to a rectangle (shown in black on the right image) in which we will search for best matching block. Notice that for the selected block from the left image, to get the corresponding image region, you will have to move the white smaller rectangle to the left in the black rectangle as shown in the third image in Figure 2.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="block_matching.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 2. Block matching example. (Image source: Middlebury Stereo Datasets)</figcaption>
</figure>
</div>
<ul>
<li>For a pixel in the left image, select the pixels in its neighborhood specified as block size from the left image.</li>
<li>Compute similarity score by comparing each block from the left image (same size as block size) and each block selected from the search block in the right image. Slide block on the right image by one pixel within the search block (black rectangle). Record all the similarity scores.</li>
<li>Find the highest pixel similarity score from the previous step. For the block with highest similarity, return the pixel location at the center of the block as the best matching pixel.</li>
<li>If <span class="math inline">\(x_{l}\)</span> is the column index of the left pixel, and the highest similarity score was obtained for a block on the right image whose center pixel has column index <span class="math inline">\(x_{r}\)</span>, we will note the disparity value of <span class="math inline">\(\left\|x_{l}-x_{r}\right\|\)</span> for the location of left image pixel.</li>
<li>Repeat the matching process for each pixel in the left image and note all the disparity values for the left image pixel index.</li>
<li>We will start building the basic building blocks first and later combine these building blocks to compute disparity map.</li>
</ul>
<section id="similarity-metric" class="level3">
<h3 class="anchored" data-anchor-id="similarity-metric">Similarity metric</h3>
<p>We need to define a notion of similarity between two blocks of pixels. Sum of absolute difference between pixel values is an intuitive metric for similarity. For example, the pair (3,5) is more similar compared to the pair (3,6) since the absolute difference between numbers in the first pair |3 - 5| &lt; difference between numbers in the second pair |3 - 6|, i.e., 2 &lt; 3. If there are multiple such values for comparison, we sum up the differences. Let’s implement sum of absolute difference method to be used for comparing blocks of pixels. We will loop over each row (<span class="math inline">\(i\)</span>) and column (<span class="math inline">\(j\)</span>) in both left and right blocks using <span class="math inline">\(\Sigma_{i,j} |B_{i,j}^{l} - B_{i,j}^{r}|\)</span>. Pixel blocks with lower sum of absolute difference value are more similar than pixel blocks with higher sum of absolute difference value.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_of_abs_diff(pixel_vals_1, pixel_vals_2):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">        pixel_vals_1 (numpy.ndarray): pixel block from left image</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">        pixel_vals_2 (numpy.ndarray): pixel block from right image</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">        float: Sum of absolute difference between individual pixels</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pixel_vals_1.shape <span class="op">!=</span> pixel_vals_2.shape:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(<span class="bu">abs</span>(pixel_vals_1 <span class="op">-</span> pixel_vals_2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="block-comparisons" class="level3">
<h3 class="anchored" data-anchor-id="block-comparisons">Block comparisons</h3>
<p>We can compare a block of pixels from the left image with a block of pixels in the right image using the <code>sum_of_abs_diff</code> method we just defined. However, note that we need to compare a single block of pixels in the left image to multiple blocks of pixels on the right image (like we defined in <code>Why do we need to specify block size and search block size?</code>). These multiple blocks are to be selected within the search block shown as a black rectangle in Figure 2. We will slide the white box one pixel at a time starting from left most position within the black box to get candidate blocks for comparison from the right image. We note the block from the right image that has lowest sum of absolute difference score. The corresponding row and column index (y, x) is returned by our implementation here.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>BLOCK_SIZE <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>SEARCH_BLOCK_SIZE <span class="op">=</span> <span class="dv">56</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_blocks(y, x, block_left, right_array, block_size<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Compare left block of pixels with multiple blocks from the right</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    image using SEARCH_BLOCK_SIZE to constrain the search in the right</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    image.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">        y (int): row index of the left block</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">        x (int): column index of the left block</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">        block_left (numpy.ndarray): containing pixel values within the</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">                    block selected from the left image</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">        right_array (numpy.ndarray]): containing pixel values for the</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">                     entrire right image</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">        block_size (int, optional): Block of pixels width and height.</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">                                    Defaults to 5.</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">        tuple: (y, x) row and column index of the best matching block</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">                in the right image</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get search range for the right image</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    x_min <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, x <span class="op">-</span> SEARCH_BLOCK_SIZE)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    x_max <span class="op">=</span> <span class="bu">min</span>(right_array.shape[<span class="dv">1</span>], x <span class="op">+</span> SEARCH_BLOCK_SIZE)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">#print(f'search bounding box: ({y, x_min}, ({y, x_max}))')</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    first <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    min_sad <span class="op">=</span> <span class="va">None</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    min_index <span class="op">=</span> <span class="va">None</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(x_min, x_max):</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        block_right <span class="op">=</span> right_array[y: y<span class="op">+</span>block_size,</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                                  x: x<span class="op">+</span>block_size]</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        sad <span class="op">=</span> sum_of_abs_diff(block_left, block_right)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">#print(f'sad: {sad}, {y, x}')</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> first:</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            min_sad <span class="op">=</span> sad</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            min_index <span class="op">=</span> (y, x)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sad <span class="op">&lt;</span> min_sad:</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>                min_sad <span class="op">=</span> sad</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>                min_index <span class="op">=</span> (y, x)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="disparity-calculation" class="level3">
<h3 class="anchored" data-anchor-id="disparity-calculation">Disparity calculation</h3>
<p>We can use the block comparison implementation to compute disparity values for every pixel between left and right images. As explained earlier, we will use a pixel blocks (neighboring pixels) to find pixel correspondences between left and right images. To do this, for a pixel at row <span class="math inline">\(r\)</span> and column <span class="math inline">\(c\)</span> from the left image, we select block of pixels <span class="math inline">\(b_{r, c}\)</span> from the left image using BLOCK*SIZE parameter. We invoke block comparison for <span class="math inline">\(b*{r, c}\)</span> and get back min_index containing row and column index of the best matching pixel from the right image, (y, x). For the pixel (r, c) of the left image, the best matching pixel from the right image is at (y, x). The disparity for pixel (r, c) is computed using <span class="math inline">\(|c - x|\)</span>. We need to compute disparity for each pixel of the left image and collect disparity values in a matrix of size width and height of the left/right image.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>h, w <span class="op">=</span> input_image.shape</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>disparity_map <span class="op">=</span> np.zeros((h, w))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>min_index <span class="op">=</span> compare_blocks(y, x, block_left, right_array, block_size<span class="op">=</span>BLOCK_SIZE)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>disparity_map[y, x] <span class="op">=</span> <span class="bu">abs</span>(min_index[<span class="dv">1</span>] <span class="op">-</span> x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="disparity-map-1" class="level3">
<h3 class="anchored" data-anchor-id="disparity-map-1">Disparity map</h3>
<p>Let’s now setup a loop to go over each pixel in the left image, select a block of pixels from the left image, invoke compare_blocks, compute disparity values, and store disparity values in a matrix referred to as the disparity map. The indexing used here is quite lossy and a careful consideration may help in reducing loss of disparity values at image borders.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> tqdm(<span class="bu">range</span>(BLOCK_SIZE, h<span class="op">-</span>BLOCK_SIZE)):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(BLOCK_SIZE, w<span class="op">-</span>BLOCK_SIZE):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>            block_left <span class="op">=</span> left_array[y:y <span class="op">+</span> BLOCK_SIZE,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                                    x:x <span class="op">+</span> BLOCK_SIZE]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            min_index <span class="op">=</span> compare_blocks(y, x, block_left,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                                       right_array,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                                       block_size<span class="op">=</span>BLOCK_SIZE)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            disparity_map[y, x] <span class="op">=</span> <span class="bu">abs</span>(min_index[<span class="dv">1</span>] <span class="op">-</span> x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here is a visualization of the disparity map computed for left and right images shown in Figure 3.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="disparity_image.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 3. Visualization of disparity values computed using left and right image of the scene shown in the first figure. Hot/lighter color indicates higher value of disparity and cooler/darker color indicates lower value of disparity</figcaption>
</figure>
</div>
<p>We use <code>tqdm</code> to show progress and note the time it takes to compute the disparity map in python. <img src="run_time_python.png" class="img-fluid" alt="Disparity map computation run time"></p>
<p>Disparity map computation using this python implementation took <code>2 minutes 37 seconds</code> for left and right images of size (height=375, width=450). I was quite disappointed by this slow run-time for such a small image size and wondered about the practical use of my python implementation. There are many optimizations proposed in <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> and <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>. The most obvious one for me is to use all the compute power on my machine. Since python cannot take advantage of all the cores on my machine, I was motivated to use C++ to parallelize the disparity map computation.</p>
</section>
</section>
<section id="parallel-implementation-in-c" class="level2">
<h2 class="anchored" data-anchor-id="parallel-implementation-in-c">Parallel implementation in C++</h2>
<p>Comparing pixel blocks from the left image (white box) with the pixel blocks from the right image can be done in parallel. A naive approach may be to create a thread pool and assign a single block comparison to a thread. Later, after block comparison for each pixel in the left image, we accumulate all the results into a disparity map. One concern is the cost of spawning a thread and later aggregating all the results which probably impedes the benefits of parallelizing this computation.</p>
<p>A slightly practical approach to parallelize this computation is to find the number of cores on the machine where you would compute the disparity map and split the computation accordingly. We can split disparity map computation into <span class="math inline">\(n\)</span> chunks where <span class="math inline">\(n\)</span> is the number of cores on your machine. Think of the left image and right image as 2D space split into <span class="math inline">\(n\)</span> horizontal strips. We will compute disparity map for each strip pair (one from left image and another from right image) in parallel. Later, we will combine the <span class="math inline">\(n\)</span> disparity maps into a single disparity map. Since this approach leverages all the cores on the machine, we should see a gain in performance.</p>
<section id="similarity-metric-and-block-comparisons" class="level3">
<h3 class="anchored" data-anchor-id="similarity-metric-and-block-comparisons">Similarity metric and block comparisons</h3>
<p>Let’s start with some basic methods we need. First, we need a method to compare blocks selected from left and right images. We will write a general method that can do block comparison for a given pixel location and pixel block width and height. Method compare_blocks implemented here returns the disparity value for a specified pixel index (row, col) and block size (width, height).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compare_blocks<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> row<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> col<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> width<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> height<span class="op">,</span> <span class="at">const</span> Mat <span class="op">*</span>left_img<span class="op">,</span> <span class="at">const</span> Mat <span class="op">*</span>right_img<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sad <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> min_col <span class="op">=</span> col<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compute bounding box for left image with (row, col) as top left point</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compute bottom right point using (row, col)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> bottom_row <span class="op">=</span> min<span class="op">(</span>row <span class="op">+</span> BLOCK_SIZE<span class="op">,</span> height <span class="op">-</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// zero indexed, hence using (height - 1)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> bottom_col <span class="op">=</span> min<span class="op">(</span>col <span class="op">+</span> BLOCK_SIZE<span class="op">,</span> width <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compute bounding box for right image block in which</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we will scan and compare left block</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col_min <span class="op">=</span> max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> col <span class="op">-</span> SEARCH_BLOCK_SIZE<span class="op">);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col_max <span class="op">=</span> min<span class="op">(</span>width<span class="op">,</span> col <span class="op">+</span> SEARCH_BLOCK_SIZE<span class="op">);</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> first_block <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> min_sad <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> r_indx <span class="op">=</span> col_min<span class="op">;</span> r_indx <span class="op">&lt;</span> col_max<span class="op">;</span> <span class="op">++</span>r_indx<span class="op">)</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        sad <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> row<span class="op">;</span> i <span class="op">&lt;</span> bottom_row<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> r_img_col <span class="op">=</span> r_indx<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> col<span class="op">;</span> j <span class="op">&lt;</span> bottom_col<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                Scalar left_pixel <span class="op">=</span> left_img<span class="op">-&gt;</span>at<span class="op">&lt;</span><span class="ex">uchar</span><span class="op">&gt;(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Right image index should be updated using offset</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">// since we need to scan both left and right of the</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                <span class="co">// block from the left image</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                Scalar right_pixel <span class="op">=</span> right_img<span class="op">-&gt;</span>at<span class="op">&lt;</span><span class="ex">uchar</span><span class="op">&gt;(</span>i<span class="op">,</span> r_img_col<span class="op">);</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>                sad <span class="op">+=</span> abs<span class="op">(</span>left_pixel<span class="op">.</span>val<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> right_pixel<span class="op">.</span>val<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span>r_img_col<span class="op">;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>first_block<span class="op">)</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>            min_sad <span class="op">=</span> sad<span class="op">;</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            min_col <span class="op">=</span> r_indx<span class="op">;</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            first_block <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>sad <span class="op">&lt;</span> min_sad<span class="op">)</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>                min_sad <span class="op">=</span> sad<span class="op">;</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>                min_col <span class="op">=</span> r_indx<span class="op">;</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">//cout &lt;&lt; "min sad: " &lt;&lt; min_sad &lt;&lt; " ";</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> col <span class="op">-</span> min_col<span class="op">;</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="disparity-calculation-1" class="level3">
<h3 class="anchored" data-anchor-id="disparity-calculation-1">Disparity calculation</h3>
<p>We can invoke block comparisons for each pixel in the left image using the following set-up. Here, the start and end rows and columns of the chunks are passed as arguments. I will next describe the derivation of these indexes.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute_disparity<span class="op">(</span><span class="dt">int</span> start_chunk_row<span class="op">,</span> <span class="dt">int</span> end_chunk_row<span class="op">,</span> <span class="dt">int</span> start_chunk_col<span class="op">,</span> <span class="dt">int</span> end_chunk_col<span class="op">,</span> Mat <span class="op">*</span>left_img<span class="op">,</span> Mat <span class="op">*</span>right_img<span class="op">,</span> Mat <span class="op">*</span>disparity_map<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height <span class="op">=</span> left_img<span class="op">-&gt;</span>rows<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> width <span class="op">=</span> left_img<span class="op">-&gt;</span>cols<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start_chunk_row<span class="op">;</span> i <span class="op">&lt;</span> end_chunk_row<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> start_chunk_col<span class="op">;</span> j <span class="op">&lt;</span> end_chunk_col<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> disp <span class="op">=</span> compare_blocks<span class="op">(</span>i<span class="op">,</span> j<span class="op">,</span> height<span class="op">,</span> width<span class="op">,</span> left_img<span class="op">,</span> right_img<span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>disp <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                mtx<span class="op">.</span>lock<span class="op">();</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                disparity_map<span class="op">-&gt;</span>at<span class="op">&lt;</span><span class="ex">uchar</span><span class="op">&gt;(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>                mtx<span class="op">.</span>unlock<span class="op">();</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                mtx<span class="op">.</span>lock<span class="op">();</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                disparity_map<span class="op">-&gt;</span>at<span class="op">&lt;</span><span class="ex">uchar</span><span class="op">&gt;(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">=</span> disp<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                mtx<span class="op">.</span>unlock<span class="op">();</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chunking" class="level3">
<h3 class="anchored" data-anchor-id="chunking">Chunking</h3>
<p>To chunk disparity map computation, we need to find the indices for each chunk we want to process. We will implement the method get_chunk_indices which takes maximum range of the index and number of chunks to produce. We will return the chunk indices.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> get_chunk_indices<span class="op">(</span><span class="dt">int</span> max<span class="op">,</span> <span class="dt">int</span> num_chunks<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> chunks<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> step <span class="op">=</span> max <span class="op">/</span> num_chunks<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> max<span class="op">;</span> i <span class="op">=</span> i <span class="op">+</span> step<span class="op">)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        chunks<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    chunks<span class="op">[</span>chunks<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> max <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> chunks<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="spawning-threads" class="level3">
<h3 class="anchored" data-anchor-id="spawning-threads">Spawning threads</h3>
<p>We will spawn specified number of threads and on each thread we will compute disparity values for a single chunk which contains left and right image strips for which we are computing the disparity values. Each thread populates the disparity map and when all the threads finish, disparity_map will contain the final disparity map.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> num_threads <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> height_chunks <span class="op">=</span> get_chunk_indices<span class="op">(</span>height<span class="op">,</span> num_threads<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> height_chunks<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    t<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> thread<span class="op">(</span>compute_disparity<span class="op">,</span> height_chunks<span class="op">[</span>i<span class="op">],</span> height_chunks<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    width <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> left_img<span class="op">,</span> right_img<span class="op">,</span> <span class="op">&amp;</span>disparity_map<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here is the console output for the parallelized computation of disparity map. Complete disparity map calculation took just <code>6 seconds</code>! Just to recap, with the python implementation, disparity map calculation took <code>2 minutes, 37 seconds</code>. Using this C++ implementation, we get 26X gain in speed for computing the disparity map.</p>
<pre class="shell"><code>$ g++ $(pkg-config --cflags --libs opencv4) -std=c++11 stereo_vision_parallel.cpp -o stereo_vision
$ ./stereo_vision data/left.png data/right.png
Left image shape: [450 x 375]
Right image shape: [450 x 375]
Initial disparity map: [450 x 375]
Total entries in disparity map: 168750
Using 8 threads for computation...
Execution time: 6 seconds (0.1) mins</code></pre>
<p>Here the visualization of the disparity map calculated using the parallel implementation. <img src="disparity_image_cpp.png" class="img-fluid" alt="Figure 4. Visualization of disparity values computed using parallel implementation in C++. Hot/lighter color indicates higher value of disparity and cooler/darker color indicates lower value of disparity"></p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>We were able to implement the basic idea of Stereo Vision to compute disparity values. Hope you enjoyed translating Stereo Vision ideas to working code! Without any optimizations, the python implementation is too slow for any practical use. With parallel implementation, we reduced the running time for 375 by 450 pixels image form <code>2 minutes 37 seconds</code> to just <code>6 seconds</code>. Even though this is a significant jump in performance, it is far from practical use for any real-time systems that rely on stereo to estimate its environment. For example, a robot using vision guided navigation cannot afford to spend 6 seconds for processing two frames (one from left and and another from right camera). A far more optimized computation is necessary especially for real-time consumption of depth information.</p>
<p><strong>All the source code presented in this post can be found <a href="https://github.com/pramodatre/cv-algorithms/tree/master/stereo_vision">here</a></strong></p>
</section>
<section id="references" class="level1">
<h1>References</h1>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Forsyth, D., &amp; Ponce, J. (2003). Computer vision: A modern approach. Upper Saddle River, N.J: Prentice Hall.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Forsyth, D., &amp; Ponce, J. (2003). Computer vision: A modern approach. Upper Saddle River, N.J: Prentice Hall.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>http://mccormickml.com/2014/01/10/stereo-vision-tutorial-part-i/<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>http://mccormickml.com/assets/StereoVision/Stereo%20Vision%20-%20Mathworks%20Example%20Article.pdf<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>http://vision.deis.unibo.it/~smatt/Seminars/StereoVision.pdf<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>https://www.cc.gatech.edu/~afb/classes/CS4495-Fall2013/slides/CS4495-06-Stereo.pdf<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>http://mccormickml.com/2014/01/10/stereo-vision-tutorial-part-i/<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>http://mccormickml.com/2014/01/10/stereo-vision-tutorial-part-i/<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>http://mccormickml.com/assets/StereoVision/Stereo%20Vision%20-%20Mathworks%20Example%20Article.pdf<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>